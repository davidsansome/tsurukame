// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wanikani.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Wanikani.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(TKMAssignment);
GPBObjCClassDeclaration(TKMDeprecatedMnemonicFile);
GPBObjCClassDeclaration(TKMDeprecatedMnemonicFile_Subject);
GPBObjCClassDeclaration(TKMFormattedText);
GPBObjCClassDeclaration(TKMKanji);
GPBObjCClassDeclaration(TKMMeaning);
GPBObjCClassDeclaration(TKMRadical);
GPBObjCClassDeclaration(TKMReading);
GPBObjCClassDeclaration(TKMSubject);
GPBObjCClassDeclaration(TKMSubjectsByLevel);
GPBObjCClassDeclaration(TKMVisuallySimilarKanji);
GPBObjCClassDeclaration(TKMVocabulary);
GPBObjCClassDeclaration(TKMVocabulary_Sentence);

#pragma mark - TKMWanikaniRoot

@implementation TKMWanikaniRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - TKMWanikaniRoot_FileDescriptor

static GPBFileDescriptor *TKMWanikaniRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"proto"
                                                 objcPrefix:@"TKM"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - TKMMeaning

@implementation TKMMeaning

@dynamic hasMeaning, meaning;
@dynamic hasType, type;

typedef struct TKMMeaning__storage_ {
  uint32_t _has_storage_[1];
  TKMMeaning_Type type;
  NSString *meaning;
} TKMMeaning__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "meaning",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMMeaning_FieldNumber_Meaning,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMMeaning__storage_, meaning),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = TKMMeaning_Type_EnumDescriptor,
        .number = TKMMeaning_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TKMMeaning__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMMeaning class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMMeaning__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TKMMeaning_Type_RawValue(TKMMeaning *message) {
  GPBDescriptor *descriptor = [TKMMeaning descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TKMMeaning_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTKMMeaning_Type_RawValue(TKMMeaning *message, int32_t value) {
  GPBDescriptor *descriptor = [TKMMeaning descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TKMMeaning_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum TKMMeaning_Type

GPBEnumDescriptor *TKMMeaning_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Primary\000Secondary\000AuxiliaryWhite"
        "list\000Blacklist\000";
    static const int32_t values[] = {
        TKMMeaning_Type_Unknown,
        TKMMeaning_Type_Primary,
        TKMMeaning_Type_Secondary,
        TKMMeaning_Type_AuxiliaryWhitelist,
        TKMMeaning_Type_Blacklist,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TKMMeaning_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TKMMeaning_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TKMMeaning_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case TKMMeaning_Type_Unknown:
    case TKMMeaning_Type_Primary:
    case TKMMeaning_Type_Secondary:
    case TKMMeaning_Type_AuxiliaryWhitelist:
    case TKMMeaning_Type_Blacklist:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TKMReading

@implementation TKMReading

@dynamic hasReading, reading;
@dynamic hasIsPrimary, isPrimary;
@dynamic hasType, type;

typedef struct TKMReading__storage_ {
  uint32_t _has_storage_[1];
  TKMReading_Type type;
  NSString *reading;
} TKMReading__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reading",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMReading_FieldNumber_Reading,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMReading__storage_, reading),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isPrimary",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMReading_FieldNumber_IsPrimary,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = TKMReading_Type_EnumDescriptor,
        .number = TKMReading_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TKMReading__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMReading class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMReading__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TKMReading_Type_RawValue(TKMReading *message) {
  GPBDescriptor *descriptor = [TKMReading descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TKMReading_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTKMReading_Type_RawValue(TKMReading *message, int32_t value) {
  GPBDescriptor *descriptor = [TKMReading descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TKMReading_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum TKMReading_Type

GPBEnumDescriptor *TKMReading_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Onyomi\000Kunyomi\000Nanori\000";
    static const int32_t values[] = {
        TKMReading_Type_Unknown,
        TKMReading_Type_Onyomi,
        TKMReading_Type_Kunyomi,
        TKMReading_Type_Nanori,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TKMReading_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TKMReading_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TKMReading_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case TKMReading_Type_Unknown:
    case TKMReading_Type_Onyomi:
    case TKMReading_Type_Kunyomi:
    case TKMReading_Type_Nanori:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TKMRadical

@implementation TKMRadical

@dynamic hasCharacterImage, characterImage;
@dynamic hasMnemonic, mnemonic;
@dynamic hasDeprecatedMnemonic, deprecatedMnemonic;
@dynamic hasHasCharacterImageFile, hasCharacterImageFile;
@dynamic formattedMnemonicArray, formattedMnemonicArray_Count;
@dynamic formattedDeprecatedMnemonicArray, formattedDeprecatedMnemonicArray_Count;

typedef struct TKMRadical__storage_ {
  uint32_t _has_storage_[1];
  NSString *characterImage;
  NSString *mnemonic;
  NSMutableArray *formattedMnemonicArray;
  NSString *deprecatedMnemonic;
  NSMutableArray *formattedDeprecatedMnemonicArray;
} TKMRadical__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "characterImage",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMRadical_FieldNumber_CharacterImage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMRadical__storage_, characterImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mnemonic",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMRadical_FieldNumber_Mnemonic,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TKMRadical__storage_, mnemonic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hasCharacterImageFile",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMRadical_FieldNumber_HasCharacterImageFile,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "formattedMnemonicArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMFormattedText),
        .number = TKMRadical_FieldNumber_FormattedMnemonicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMRadical__storage_, formattedMnemonicArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deprecatedMnemonic",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMRadical_FieldNumber_DeprecatedMnemonic,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TKMRadical__storage_, deprecatedMnemonic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "formattedDeprecatedMnemonicArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMFormattedText),
        .number = TKMRadical_FieldNumber_FormattedDeprecatedMnemonicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMRadical__storage_, formattedDeprecatedMnemonicArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMRadical class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMRadical__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TKMVisuallySimilarKanji

@implementation TKMVisuallySimilarKanji

@dynamic hasId_p, id_p;
@dynamic hasScore, score;

typedef struct TKMVisuallySimilarKanji__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t score;
} TKMVisuallySimilarKanji__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMVisuallySimilarKanji_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMVisuallySimilarKanji__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "score",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMVisuallySimilarKanji_FieldNumber_Score,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TKMVisuallySimilarKanji__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMVisuallySimilarKanji class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMVisuallySimilarKanji__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TKMKanji

@implementation TKMKanji

@dynamic hasMeaningMnemonic, meaningMnemonic;
@dynamic hasMeaningHint, meaningHint;
@dynamic hasReadingMnemonic, readingMnemonic;
@dynamic hasReadingHint, readingHint;
@dynamic formattedMeaningMnemonicArray, formattedMeaningMnemonicArray_Count;
@dynamic formattedMeaningHintArray, formattedMeaningHintArray_Count;
@dynamic formattedReadingMnemonicArray, formattedReadingMnemonicArray_Count;
@dynamic formattedReadingHintArray, formattedReadingHintArray_Count;
@dynamic visuallySimilarKanjiArray, visuallySimilarKanjiArray_Count;

typedef struct TKMKanji__storage_ {
  uint32_t _has_storage_[1];
  NSString *meaningMnemonic;
  NSString *meaningHint;
  NSString *readingMnemonic;
  NSString *readingHint;
  NSMutableArray *formattedMeaningMnemonicArray;
  NSMutableArray *formattedMeaningHintArray;
  NSMutableArray *formattedReadingMnemonicArray;
  NSMutableArray *formattedReadingHintArray;
  NSMutableArray *visuallySimilarKanjiArray;
} TKMKanji__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "meaningMnemonic",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMKanji_FieldNumber_MeaningMnemonic,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMKanji__storage_, meaningMnemonic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meaningHint",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMKanji_FieldNumber_MeaningHint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TKMKanji__storage_, meaningHint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readingMnemonic",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMKanji_FieldNumber_ReadingMnemonic,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TKMKanji__storage_, readingMnemonic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readingHint",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMKanji_FieldNumber_ReadingHint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TKMKanji__storage_, readingHint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "formattedMeaningMnemonicArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMFormattedText),
        .number = TKMKanji_FieldNumber_FormattedMeaningMnemonicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMKanji__storage_, formattedMeaningMnemonicArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "formattedMeaningHintArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMFormattedText),
        .number = TKMKanji_FieldNumber_FormattedMeaningHintArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMKanji__storage_, formattedMeaningHintArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "formattedReadingMnemonicArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMFormattedText),
        .number = TKMKanji_FieldNumber_FormattedReadingMnemonicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMKanji__storage_, formattedReadingMnemonicArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "formattedReadingHintArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMFormattedText),
        .number = TKMKanji_FieldNumber_FormattedReadingHintArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMKanji__storage_, formattedReadingHintArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "visuallySimilarKanjiArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMVisuallySimilarKanji),
        .number = TKMKanji_FieldNumber_VisuallySimilarKanjiArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMKanji__storage_, visuallySimilarKanjiArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMKanji class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMKanji__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TKMVocabulary

@implementation TKMVocabulary

@dynamic hasMeaningExplanation, meaningExplanation;
@dynamic hasReadingExplanation, readingExplanation;
@dynamic formattedMeaningExplanationArray, formattedMeaningExplanationArray_Count;
@dynamic formattedReadingExplanationArray, formattedReadingExplanationArray_Count;
@dynamic sentencesArray, sentencesArray_Count;
@dynamic partsOfSpeechArray, partsOfSpeechArray_Count;
@dynamic audioIdsArray, audioIdsArray_Count;

typedef struct TKMVocabulary__storage_ {
  uint32_t _has_storage_[1];
  NSString *meaningExplanation;
  NSString *readingExplanation;
  NSMutableArray *sentencesArray;
  GPBEnumArray *partsOfSpeechArray;
  GPBInt32Array *audioIdsArray;
  NSMutableArray *formattedMeaningExplanationArray;
  NSMutableArray *formattedReadingExplanationArray;
} TKMVocabulary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "meaningExplanation",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMVocabulary_FieldNumber_MeaningExplanation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMVocabulary__storage_, meaningExplanation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readingExplanation",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMVocabulary_FieldNumber_ReadingExplanation,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TKMVocabulary__storage_, readingExplanation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sentencesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMVocabulary_Sentence),
        .number = TKMVocabulary_FieldNumber_SentencesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMVocabulary__storage_, sentencesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "partsOfSpeechArray",
        .dataTypeSpecific.enumDescFunc = TKMVocabulary_PartOfSpeech_EnumDescriptor,
        .number = TKMVocabulary_FieldNumber_PartsOfSpeechArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMVocabulary__storage_, partsOfSpeechArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "audioIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMVocabulary_FieldNumber_AudioIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMVocabulary__storage_, audioIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "formattedMeaningExplanationArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMFormattedText),
        .number = TKMVocabulary_FieldNumber_FormattedMeaningExplanationArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMVocabulary__storage_, formattedMeaningExplanationArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "formattedReadingExplanationArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMFormattedText),
        .number = TKMVocabulary_FieldNumber_FormattedReadingExplanationArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMVocabulary__storage_, formattedReadingExplanationArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMVocabulary class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMVocabulary__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum TKMVocabulary_PartOfSpeech

GPBEnumDescriptor *TKMVocabulary_PartOfSpeech_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Noun\000Numeral\000IntransitiveVerb\000Ic"
        "hidanVerb\000TransitiveVerb\000NoAdjective\000God"
        "anVerb\000NaAdjective\000IAdjective\000Suffix\000Adv"
        "erb\000SuruVerb\000Prefix\000ProperNoun\000Expressio"
        "n\000Adjective\000Interjection\000Counter\000Pronoun"
        "\000Conjunction\000";
    static const int32_t values[] = {
        TKMVocabulary_PartOfSpeech_Unknown,
        TKMVocabulary_PartOfSpeech_Noun,
        TKMVocabulary_PartOfSpeech_Numeral,
        TKMVocabulary_PartOfSpeech_IntransitiveVerb,
        TKMVocabulary_PartOfSpeech_IchidanVerb,
        TKMVocabulary_PartOfSpeech_TransitiveVerb,
        TKMVocabulary_PartOfSpeech_NoAdjective,
        TKMVocabulary_PartOfSpeech_GodanVerb,
        TKMVocabulary_PartOfSpeech_NaAdjective,
        TKMVocabulary_PartOfSpeech_IAdjective,
        TKMVocabulary_PartOfSpeech_Suffix,
        TKMVocabulary_PartOfSpeech_Adverb,
        TKMVocabulary_PartOfSpeech_SuruVerb,
        TKMVocabulary_PartOfSpeech_Prefix,
        TKMVocabulary_PartOfSpeech_ProperNoun,
        TKMVocabulary_PartOfSpeech_Expression,
        TKMVocabulary_PartOfSpeech_Adjective,
        TKMVocabulary_PartOfSpeech_Interjection,
        TKMVocabulary_PartOfSpeech_Counter,
        TKMVocabulary_PartOfSpeech_Pronoun,
        TKMVocabulary_PartOfSpeech_Conjunction,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TKMVocabulary_PartOfSpeech)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TKMVocabulary_PartOfSpeech_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TKMVocabulary_PartOfSpeech_IsValidValue(int32_t value__) {
  switch (value__) {
    case TKMVocabulary_PartOfSpeech_Unknown:
    case TKMVocabulary_PartOfSpeech_Noun:
    case TKMVocabulary_PartOfSpeech_Numeral:
    case TKMVocabulary_PartOfSpeech_IntransitiveVerb:
    case TKMVocabulary_PartOfSpeech_IchidanVerb:
    case TKMVocabulary_PartOfSpeech_TransitiveVerb:
    case TKMVocabulary_PartOfSpeech_NoAdjective:
    case TKMVocabulary_PartOfSpeech_GodanVerb:
    case TKMVocabulary_PartOfSpeech_NaAdjective:
    case TKMVocabulary_PartOfSpeech_IAdjective:
    case TKMVocabulary_PartOfSpeech_Suffix:
    case TKMVocabulary_PartOfSpeech_Adverb:
    case TKMVocabulary_PartOfSpeech_SuruVerb:
    case TKMVocabulary_PartOfSpeech_Prefix:
    case TKMVocabulary_PartOfSpeech_ProperNoun:
    case TKMVocabulary_PartOfSpeech_Expression:
    case TKMVocabulary_PartOfSpeech_Adjective:
    case TKMVocabulary_PartOfSpeech_Interjection:
    case TKMVocabulary_PartOfSpeech_Counter:
    case TKMVocabulary_PartOfSpeech_Pronoun:
    case TKMVocabulary_PartOfSpeech_Conjunction:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TKMVocabulary_Sentence

@implementation TKMVocabulary_Sentence

@dynamic hasJapanese, japanese;
@dynamic hasEnglish, english;

typedef struct TKMVocabulary_Sentence__storage_ {
  uint32_t _has_storage_[1];
  NSString *japanese;
  NSString *english;
} TKMVocabulary_Sentence__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "japanese",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMVocabulary_Sentence_FieldNumber_Japanese,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMVocabulary_Sentence__storage_, japanese),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "english",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMVocabulary_Sentence_FieldNumber_English,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TKMVocabulary_Sentence__storage_, english),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMVocabulary_Sentence class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMVocabulary_Sentence__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(TKMVocabulary)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TKMSubject

@implementation TKMSubject

@dynamic hasId_p, id_p;
@dynamic hasLevel, level;
@dynamic hasSlug, slug;
@dynamic hasDocumentURL, documentURL;
@dynamic hasJapanese, japanese;
@dynamic readingsArray, readingsArray_Count;
@dynamic meaningsArray, meaningsArray_Count;
@dynamic componentSubjectIdsArray, componentSubjectIdsArray_Count;
@dynamic amalgamationSubjectIdsArray, amalgamationSubjectIdsArray_Count;
@dynamic hasRadical, radical;
@dynamic hasKanji, kanji;
@dynamic hasVocabulary, vocabulary;

typedef struct TKMSubject__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t level;
  NSString *slug;
  NSString *documentURL;
  NSString *japanese;
  NSMutableArray *readingsArray;
  NSMutableArray *meaningsArray;
  GPBInt32Array *componentSubjectIdsArray;
  TKMRadical *radical;
  TKMKanji *kanji;
  TKMVocabulary *vocabulary;
  GPBInt32Array *amalgamationSubjectIdsArray;
} TKMSubject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMSubject_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMSubject__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMSubject_FieldNumber_Level,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TKMSubject__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "slug",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMSubject_FieldNumber_Slug,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TKMSubject__storage_, slug),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "documentURL",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMSubject_FieldNumber_DocumentURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TKMSubject__storage_, documentURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "japanese",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMSubject_FieldNumber_Japanese,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TKMSubject__storage_, japanese),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readingsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMReading),
        .number = TKMSubject_FieldNumber_ReadingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMSubject__storage_, readingsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meaningsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMMeaning),
        .number = TKMSubject_FieldNumber_MeaningsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMSubject__storage_, meaningsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "componentSubjectIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMSubject_FieldNumber_ComponentSubjectIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMSubject__storage_, componentSubjectIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "radical",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMRadical),
        .number = TKMSubject_FieldNumber_Radical,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TKMSubject__storage_, radical),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "kanji",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMKanji),
        .number = TKMSubject_FieldNumber_Kanji,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TKMSubject__storage_, kanji),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vocabulary",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMVocabulary),
        .number = TKMSubject_FieldNumber_Vocabulary,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TKMSubject__storage_, vocabulary),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amalgamationSubjectIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMSubject_FieldNumber_AmalgamationSubjectIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMSubject__storage_, amalgamationSubjectIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMSubject class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMSubject__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\010\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum TKMSubject_Type

GPBEnumDescriptor *TKMSubject_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Radical\000Kanji\000Vocabulary\000";
    static const int32_t values[] = {
        TKMSubject_Type_Unknown,
        TKMSubject_Type_Radical,
        TKMSubject_Type_Kanji,
        TKMSubject_Type_Vocabulary,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TKMSubject_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TKMSubject_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TKMSubject_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case TKMSubject_Type_Unknown:
    case TKMSubject_Type_Radical:
    case TKMSubject_Type_Kanji:
    case TKMSubject_Type_Vocabulary:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TKMAssignment

@implementation TKMAssignment

@dynamic hasId_p, id_p;
@dynamic hasLevel, level;
@dynamic hasSubjectId, subjectId;
@dynamic hasSubjectType, subjectType;
@dynamic hasAvailableAt, availableAt;
@dynamic hasStartedAt, startedAt;
@dynamic hasSrsStage, srsStage;
@dynamic hasPassedAt, passedAt;

typedef struct TKMAssignment__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t level;
  int32_t subjectId;
  TKMSubject_Type subjectType;
  int32_t availableAt;
  int32_t startedAt;
  int32_t srsStage;
  int32_t passedAt;
} TKMAssignment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMAssignment_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMAssignment__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMAssignment_FieldNumber_Level,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TKMAssignment__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subjectId",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMAssignment_FieldNumber_SubjectId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TKMAssignment__storage_, subjectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subjectType",
        .dataTypeSpecific.enumDescFunc = TKMSubject_Type_EnumDescriptor,
        .number = TKMAssignment_FieldNumber_SubjectType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TKMAssignment__storage_, subjectType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "availableAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMAssignment_FieldNumber_AvailableAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TKMAssignment__storage_, availableAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMAssignment_FieldNumber_StartedAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TKMAssignment__storage_, startedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "srsStage",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMAssignment_FieldNumber_SrsStage,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TKMAssignment__storage_, srsStage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "passedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMAssignment_FieldNumber_PassedAt,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TKMAssignment__storage_, passedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMAssignment class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMAssignment__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TKMAssignment_SubjectType_RawValue(TKMAssignment *message) {
  GPBDescriptor *descriptor = [TKMAssignment descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TKMAssignment_FieldNumber_SubjectType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTKMAssignment_SubjectType_RawValue(TKMAssignment *message, int32_t value) {
  GPBDescriptor *descriptor = [TKMAssignment descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TKMAssignment_FieldNumber_SubjectType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - TKMProgress

@implementation TKMProgress

@dynamic hasMeaningWrong, meaningWrong;
@dynamic hasReadingWrong, readingWrong;
@dynamic hasIsLesson, isLesson;
@dynamic hasAssignment, assignment;
@dynamic hasCreatedAt, createdAt;

typedef struct TKMProgress__storage_ {
  uint32_t _has_storage_[1];
  int32_t createdAt;
  TKMAssignment *assignment;
} TKMProgress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "meaningWrong",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMProgress_FieldNumber_MeaningWrong,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "readingWrong",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMProgress_FieldNumber_ReadingWrong,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isLesson",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMProgress_FieldNumber_IsLesson,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "assignment",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMAssignment),
        .number = TKMProgress_FieldNumber_Assignment,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TKMProgress__storage_, assignment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMProgress_FieldNumber_CreatedAt,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TKMProgress__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMProgress class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMProgress__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TKMStudyMaterials

@implementation TKMStudyMaterials

@dynamic hasId_p, id_p;
@dynamic hasSubjectId, subjectId;
@dynamic hasSubjectType, subjectType;
@dynamic hasMeaningNote, meaningNote;
@dynamic hasReadingNote, readingNote;
@dynamic meaningSynonymsArray, meaningSynonymsArray_Count;

typedef struct TKMStudyMaterials__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t subjectId;
  NSString *meaningNote;
  NSString *readingNote;
  NSMutableArray *meaningSynonymsArray;
  NSString *subjectType;
} TKMStudyMaterials__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMStudyMaterials_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMStudyMaterials__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subjectId",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMStudyMaterials_FieldNumber_SubjectId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TKMStudyMaterials__storage_, subjectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "meaningNote",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMStudyMaterials_FieldNumber_MeaningNote,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TKMStudyMaterials__storage_, meaningNote),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readingNote",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMStudyMaterials_FieldNumber_ReadingNote,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TKMStudyMaterials__storage_, readingNote),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meaningSynonymsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMStudyMaterials_FieldNumber_MeaningSynonymsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMStudyMaterials__storage_, meaningSynonymsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subjectType",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMStudyMaterials_FieldNumber_SubjectType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TKMStudyMaterials__storage_, subjectType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMStudyMaterials class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMStudyMaterials__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TKMUser

@implementation TKMUser

@dynamic hasUsername, username;
@dynamic hasLevel, level;
@dynamic hasMaxLevelGrantedBySubscription, maxLevelGrantedBySubscription;
@dynamic hasProfileURL, profileURL;
@dynamic hasStartedAt, startedAt;
@dynamic hasSubscribed, subscribed;
@dynamic hasSubscriptionEndsAt, subscriptionEndsAt;
@dynamic hasVacationStartedAt, vacationStartedAt;

typedef struct TKMUser__storage_ {
  uint32_t _has_storage_[1];
  int32_t level;
  int32_t maxLevelGrantedBySubscription;
  int32_t startedAt;
  int32_t subscriptionEndsAt;
  int32_t vacationStartedAt;
  NSString *username;
  NSString *profileURL;
} TKMUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMUser_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMUser__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMUser_FieldNumber_Level,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TKMUser__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxLevelGrantedBySubscription",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMUser_FieldNumber_MaxLevelGrantedBySubscription,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TKMUser__storage_, maxLevelGrantedBySubscription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "profileURL",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMUser_FieldNumber_ProfileURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TKMUser__storage_, profileURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMUser_FieldNumber_StartedAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TKMUser__storage_, startedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subscribed",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMUser_FieldNumber_Subscribed,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "subscriptionEndsAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMUser_FieldNumber_SubscriptionEndsAt,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TKMUser__storage_, subscriptionEndsAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "vacationStartedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMUser_FieldNumber_VacationStartedAt,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(TKMUser__storage_, vacationStartedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMUser class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMUser__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\007\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TKMSubjectOverrides

@implementation TKMSubjectOverrides

@dynamic subjectArray, subjectArray_Count;

typedef struct TKMSubjectOverrides__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *subjectArray;
} TKMSubjectOverrides__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subjectArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMSubject),
        .number = TKMSubjectOverrides_FieldNumber_SubjectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMSubjectOverrides__storage_, subjectArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMSubjectOverrides class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMSubjectOverrides__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TKMFormattedText

@implementation TKMFormattedText

@dynamic formatArray, formatArray_Count;
@dynamic hasText, text;
@dynamic hasLinkURL, linkURL;

typedef struct TKMFormattedText__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *formatArray;
  NSString *text;
  NSString *linkURL;
} TKMFormattedText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "formatArray",
        .dataTypeSpecific.enumDescFunc = TKMFormattedText_Format_EnumDescriptor,
        .number = TKMFormattedText_FieldNumber_FormatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMFormattedText__storage_, formatArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMFormattedText_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMFormattedText__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linkURL",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMFormattedText_FieldNumber_LinkURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TKMFormattedText__storage_, linkURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMFormattedText class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMFormattedText__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum TKMFormattedText_Format

GPBEnumDescriptor *TKMFormattedText_Format_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Radical\000Kanji\000Japanese\000Reading\000V"
        "ocabulary\000Italic\000Bold\000Link\000";
    static const int32_t values[] = {
        TKMFormattedText_Format_Unknown,
        TKMFormattedText_Format_Radical,
        TKMFormattedText_Format_Kanji,
        TKMFormattedText_Format_Japanese,
        TKMFormattedText_Format_Reading,
        TKMFormattedText_Format_Vocabulary,
        TKMFormattedText_Format_Italic,
        TKMFormattedText_Format_Bold,
        TKMFormattedText_Format_Link,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TKMFormattedText_Format)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TKMFormattedText_Format_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TKMFormattedText_Format_IsValidValue(int32_t value__) {
  switch (value__) {
    case TKMFormattedText_Format_Unknown:
    case TKMFormattedText_Format_Radical:
    case TKMFormattedText_Format_Kanji:
    case TKMFormattedText_Format_Japanese:
    case TKMFormattedText_Format_Reading:
    case TKMFormattedText_Format_Vocabulary:
    case TKMFormattedText_Format_Italic:
    case TKMFormattedText_Format_Bold:
    case TKMFormattedText_Format_Link:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TKMDataFileHeader

@implementation TKMDataFileHeader

@dynamic subjectsByLevelArray, subjectsByLevelArray_Count;
@dynamic levelBySubjectArray, levelBySubjectArray_Count;
@dynamic deletedSubjectIdsArray, deletedSubjectIdsArray_Count;
@dynamic subjectByteOffsetArray, subjectByteOffsetArray_Count;

typedef struct TKMDataFileHeader__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *subjectsByLevelArray;
  GPBUInt32Array *subjectByteOffsetArray;
  GPBInt32Array *deletedSubjectIdsArray;
  GPBInt32Array *levelBySubjectArray;
} TKMDataFileHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subjectsByLevelArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMSubjectsByLevel),
        .number = TKMDataFileHeader_FieldNumber_SubjectsByLevelArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMDataFileHeader__storage_, subjectsByLevelArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "subjectByteOffsetArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMDataFileHeader_FieldNumber_SubjectByteOffsetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMDataFileHeader__storage_, subjectByteOffsetArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deletedSubjectIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMDataFileHeader_FieldNumber_DeletedSubjectIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMDataFileHeader__storage_, deletedSubjectIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "levelBySubjectArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMDataFileHeader_FieldNumber_LevelBySubjectArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMDataFileHeader__storage_, levelBySubjectArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMDataFileHeader class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMDataFileHeader__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TKMSubjectsByLevel

@implementation TKMSubjectsByLevel

@dynamic radicalsArray, radicalsArray_Count;
@dynamic kanjiArray, kanjiArray_Count;
@dynamic vocabularyArray, vocabularyArray_Count;

typedef struct TKMSubjectsByLevel__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *radicalsArray;
  GPBInt32Array *kanjiArray;
  GPBInt32Array *vocabularyArray;
} TKMSubjectsByLevel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "radicalsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMSubjectsByLevel_FieldNumber_RadicalsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMSubjectsByLevel__storage_, radicalsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "kanjiArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMSubjectsByLevel_FieldNumber_KanjiArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMSubjectsByLevel__storage_, kanjiArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "vocabularyArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMSubjectsByLevel_FieldNumber_VocabularyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMSubjectsByLevel__storage_, vocabularyArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMSubjectsByLevel class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMSubjectsByLevel__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TKMLevel

@implementation TKMLevel

@dynamic hasId_p, id_p;
@dynamic hasLevel, level;
@dynamic hasAbandonedAt, abandonedAt;
@dynamic hasCompletedAt, completedAt;
@dynamic hasCreatedAt, createdAt;
@dynamic hasPassedAt, passedAt;
@dynamic hasStartedAt, startedAt;
@dynamic hasUnlockedAt, unlockedAt;

typedef struct TKMLevel__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t level;
  int32_t abandonedAt;
  int32_t completedAt;
  int32_t createdAt;
  int32_t passedAt;
  int32_t startedAt;
  int32_t unlockedAt;
} TKMLevel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMLevel_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMLevel__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMLevel_FieldNumber_Level,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TKMLevel__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "abandonedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMLevel_FieldNumber_AbandonedAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TKMLevel__storage_, abandonedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "completedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMLevel_FieldNumber_CompletedAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TKMLevel__storage_, completedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMLevel_FieldNumber_CreatedAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TKMLevel__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "passedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMLevel_FieldNumber_PassedAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TKMLevel__storage_, passedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMLevel_FieldNumber_StartedAt,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TKMLevel__storage_, startedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "unlockedAt",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMLevel_FieldNumber_UnlockedAt,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TKMLevel__storage_, unlockedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMLevel class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMLevel__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TKMDeprecatedMnemonicFile

@implementation TKMDeprecatedMnemonicFile

@dynamic subjectsArray, subjectsArray_Count;

typedef struct TKMDeprecatedMnemonicFile__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *subjectsArray;
} TKMDeprecatedMnemonicFile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subjectsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMDeprecatedMnemonicFile_Subject),
        .number = TKMDeprecatedMnemonicFile_FieldNumber_SubjectsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMDeprecatedMnemonicFile__storage_, subjectsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMDeprecatedMnemonicFile class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMDeprecatedMnemonicFile__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TKMDeprecatedMnemonicFile_Subject

@implementation TKMDeprecatedMnemonicFile_Subject

@dynamic hasId_p, id_p;
@dynamic formattedDeprecatedMnemonicArray, formattedDeprecatedMnemonicArray_Count;

typedef struct TKMDeprecatedMnemonicFile_Subject__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSMutableArray *formattedDeprecatedMnemonicArray;
} TKMDeprecatedMnemonicFile_Subject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = TKMDeprecatedMnemonicFile_Subject_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TKMDeprecatedMnemonicFile_Subject__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "formattedDeprecatedMnemonicArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TKMFormattedText),
        .number = TKMDeprecatedMnemonicFile_Subject_FieldNumber_FormattedDeprecatedMnemonicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TKMDeprecatedMnemonicFile_Subject__storage_, formattedDeprecatedMnemonicArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TKMDeprecatedMnemonicFile_Subject class]
                                     rootClass:[TKMWanikaniRoot class]
                                          file:TKMWanikaniRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TKMDeprecatedMnemonicFile_Subject__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(TKMDeprecatedMnemonicFile)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
