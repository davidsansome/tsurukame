// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: wanikani_api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 David Sansome
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct TKMMeaning {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var meaning: String {
    get {return _meaning ?? String()}
    set {_meaning = newValue}
  }
  /// Returns true if `meaning` has been explicitly set.
  public var hasMeaning: Bool {return self._meaning != nil}
  /// Clears the value of `meaning`. Subsequent reads from it will return its default value.
  public mutating func clearMeaning() {self._meaning = nil}

  public var type: TKMMeaning.TypeEnum {
    get {return _type ?? .unknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case primary // = 1
    case secondary // = 2

    /// Old meaning for a radical that was changed.
    case auxiliaryWhitelist // = 3

    /// Similar (within edit distance) to an accepted reading but incorrect.
    case blacklist // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .primary
      case 2: self = .secondary
      case 3: self = .auxiliaryWhitelist
      case 4: self = .blacklist
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .primary: return 1
      case .secondary: return 2
      case .auxiliaryWhitelist: return 3
      case .blacklist: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _meaning: String? = nil
  fileprivate var _type: TKMMeaning.TypeEnum? = nil
}

#if swift(>=4.2)

extension TKMMeaning.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TKMMeaning.TypeEnum] = [
    .unknown,
    .primary,
    .secondary,
    .auxiliaryWhitelist,
    .blacklist,
  ]
}

#endif  // swift(>=4.2)

public struct TKMReading {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reading: String {
    get {return _reading ?? String()}
    set {_reading = newValue}
  }
  /// Returns true if `reading` has been explicitly set.
  public var hasReading: Bool {return self._reading != nil}
  /// Clears the value of `reading`. Subsequent reads from it will return its default value.
  public mutating func clearReading() {self._reading = nil}

  /// Non-primary readings are not accepted for Kanji.
  /// TODO: use the accepted_answer field instead.
  public var isPrimary: Bool {
    get {return _isPrimary ?? false}
    set {_isPrimary = newValue}
  }
  /// Returns true if `isPrimary` has been explicitly set.
  public var hasIsPrimary: Bool {return self._isPrimary != nil}
  /// Clears the value of `isPrimary`. Subsequent reads from it will return its default value.
  public mutating func clearIsPrimary() {self._isPrimary = nil}

  public var type: TKMReading.TypeEnum {
    get {return _type ?? .unknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type is only set for Kanji readings - not for Vocabulary.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case onyomi // = 1
    case kunyomi // = 2
    case nanori // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .onyomi
      case 2: self = .kunyomi
      case 3: self = .nanori
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .onyomi: return 1
      case .kunyomi: return 2
      case .nanori: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _reading: String? = nil
  fileprivate var _isPrimary: Bool? = nil
  fileprivate var _type: TKMReading.TypeEnum? = nil
}

#if swift(>=4.2)

extension TKMReading.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TKMReading.TypeEnum] = [
    .unknown,
    .onyomi,
    .kunyomi,
    .nanori,
  ]
}

#endif  // swift(>=4.2)

public struct TKMRadical {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Not present in final data.
  public var characterImage: String {
    get {return _characterImage ?? String()}
    set {_characterImage = newValue}
  }
  /// Returns true if `characterImage` has been explicitly set.
  public var hasCharacterImage: Bool {return self._characterImage != nil}
  /// Clears the value of `characterImage`. Subsequent reads from it will return its default value.
  public mutating func clearCharacterImage() {self._characterImage = nil}

  public var mnemonic: String {
    get {return _mnemonic ?? String()}
    set {_mnemonic = newValue}
  }
  /// Returns true if `mnemonic` has been explicitly set.
  public var hasMnemonic: Bool {return self._mnemonic != nil}
  /// Clears the value of `mnemonic`. Subsequent reads from it will return its default value.
  public mutating func clearMnemonic() {self._mnemonic = nil}

  public var deprecatedMnemonic: String {
    get {return _deprecatedMnemonic ?? String()}
    set {_deprecatedMnemonic = newValue}
  }
  /// Returns true if `deprecatedMnemonic` has been explicitly set.
  public var hasDeprecatedMnemonic: Bool {return self._deprecatedMnemonic != nil}
  /// Clears the value of `deprecatedMnemonic`. Subsequent reads from it will return its default value.
  public mutating func clearDeprecatedMnemonic() {self._deprecatedMnemonic = nil}

  public var hasCharacterImageFile_p: Bool {
    get {return _hasCharacterImageFile_p ?? false}
    set {_hasCharacterImageFile_p = newValue}
  }
  /// Returns true if `hasCharacterImageFile_p` has been explicitly set.
  public var hasHasCharacterImageFile_p: Bool {return self._hasCharacterImageFile_p != nil}
  /// Clears the value of `hasCharacterImageFile_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasCharacterImageFile_p() {self._hasCharacterImageFile_p = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _characterImage: String? = nil
  fileprivate var _mnemonic: String? = nil
  fileprivate var _deprecatedMnemonic: String? = nil
  fileprivate var _hasCharacterImageFile_p: Bool? = nil
}

public struct TKMKanji {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var meaningMnemonic: String {
    get {return _meaningMnemonic ?? String()}
    set {_meaningMnemonic = newValue}
  }
  /// Returns true if `meaningMnemonic` has been explicitly set.
  public var hasMeaningMnemonic: Bool {return self._meaningMnemonic != nil}
  /// Clears the value of `meaningMnemonic`. Subsequent reads from it will return its default value.
  public mutating func clearMeaningMnemonic() {self._meaningMnemonic = nil}

  public var meaningHint: String {
    get {return _meaningHint ?? String()}
    set {_meaningHint = newValue}
  }
  /// Returns true if `meaningHint` has been explicitly set.
  public var hasMeaningHint: Bool {return self._meaningHint != nil}
  /// Clears the value of `meaningHint`. Subsequent reads from it will return its default value.
  public mutating func clearMeaningHint() {self._meaningHint = nil}

  public var readingMnemonic: String {
    get {return _readingMnemonic ?? String()}
    set {_readingMnemonic = newValue}
  }
  /// Returns true if `readingMnemonic` has been explicitly set.
  public var hasReadingMnemonic: Bool {return self._readingMnemonic != nil}
  /// Clears the value of `readingMnemonic`. Subsequent reads from it will return its default value.
  public mutating func clearReadingMnemonic() {self._readingMnemonic = nil}

  public var readingHint: String {
    get {return _readingHint ?? String()}
    set {_readingHint = newValue}
  }
  /// Returns true if `readingHint` has been explicitly set.
  public var hasReadingHint: Bool {return self._readingHint != nil}
  /// Clears the value of `readingHint`. Subsequent reads from it will return its default value.
  public mutating func clearReadingHint() {self._readingHint = nil}

  public var visuallySimilarKanji: String {
    get {return _visuallySimilarKanji ?? String()}
    set {_visuallySimilarKanji = newValue}
  }
  /// Returns true if `visuallySimilarKanji` has been explicitly set.
  public var hasVisuallySimilarKanji: Bool {return self._visuallySimilarKanji != nil}
  /// Clears the value of `visuallySimilarKanji`. Subsequent reads from it will return its default value.
  public mutating func clearVisuallySimilarKanji() {self._visuallySimilarKanji = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _meaningMnemonic: String? = nil
  fileprivate var _meaningHint: String? = nil
  fileprivate var _readingMnemonic: String? = nil
  fileprivate var _readingHint: String? = nil
  fileprivate var _visuallySimilarKanji: String? = nil
}

public struct TKMVocabulary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var meaningExplanation: String {
    get {return _meaningExplanation ?? String()}
    set {_meaningExplanation = newValue}
  }
  /// Returns true if `meaningExplanation` has been explicitly set.
  public var hasMeaningExplanation: Bool {return self._meaningExplanation != nil}
  /// Clears the value of `meaningExplanation`. Subsequent reads from it will return its default value.
  public mutating func clearMeaningExplanation() {self._meaningExplanation = nil}

  public var readingExplanation: String {
    get {return _readingExplanation ?? String()}
    set {_readingExplanation = newValue}
  }
  /// Returns true if `readingExplanation` has been explicitly set.
  public var hasReadingExplanation: Bool {return self._readingExplanation != nil}
  /// Clears the value of `readingExplanation`. Subsequent reads from it will return its default value.
  public mutating func clearReadingExplanation() {self._readingExplanation = nil}

  public var sentences: [TKMVocabulary.Sentence] = []

  public var partsOfSpeech: [TKMVocabulary.PartOfSpeech] = []

  public var audio: [TKMVocabulary.PronunciationAudio] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PartOfSpeech: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case noun // = 1
    case numeral // = 2
    case intransitiveVerb // = 3
    case ichidanVerb // = 4
    case transitiveVerb // = 5
    case noAdjective // = 6
    case godanVerb // = 7
    case naAdjective // = 8
    case iAdjective // = 9
    case suffix // = 10
    case adverb // = 11
    case suruVerb // = 12
    case prefix // = 13
    case properNoun // = 14
    case expression // = 15
    case adjective // = 16
    case interjection // = 17
    case counter // = 18
    case pronoun // = 19
    case conjunction // = 20
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .noun
      case 2: self = .numeral
      case 3: self = .intransitiveVerb
      case 4: self = .ichidanVerb
      case 5: self = .transitiveVerb
      case 6: self = .noAdjective
      case 7: self = .godanVerb
      case 8: self = .naAdjective
      case 9: self = .iAdjective
      case 10: self = .suffix
      case 11: self = .adverb
      case 12: self = .suruVerb
      case 13: self = .prefix
      case 14: self = .properNoun
      case 15: self = .expression
      case 16: self = .adjective
      case 17: self = .interjection
      case 18: self = .counter
      case 19: self = .pronoun
      case 20: self = .conjunction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .noun: return 1
      case .numeral: return 2
      case .intransitiveVerb: return 3
      case .ichidanVerb: return 4
      case .transitiveVerb: return 5
      case .noAdjective: return 6
      case .godanVerb: return 7
      case .naAdjective: return 8
      case .iAdjective: return 9
      case .suffix: return 10
      case .adverb: return 11
      case .suruVerb: return 12
      case .prefix: return 13
      case .properNoun: return 14
      case .expression: return 15
      case .adjective: return 16
      case .interjection: return 17
      case .counter: return 18
      case .pronoun: return 19
      case .conjunction: return 20
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Sentence {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var japanese: String {
      get {return _japanese ?? String()}
      set {_japanese = newValue}
    }
    /// Returns true if `japanese` has been explicitly set.
    public var hasJapanese: Bool {return self._japanese != nil}
    /// Clears the value of `japanese`. Subsequent reads from it will return its default value.
    public mutating func clearJapanese() {self._japanese = nil}

    public var english: String {
      get {return _english ?? String()}
      set {_english = newValue}
    }
    /// Returns true if `english` has been explicitly set.
    public var hasEnglish: Bool {return self._english != nil}
    /// Clears the value of `english`. Subsequent reads from it will return its default value.
    public mutating func clearEnglish() {self._english = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _japanese: String? = nil
    fileprivate var _english: String? = nil
  }

  public struct PronunciationAudio {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var url: String {
      get {return _url ?? String()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    public var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    public mutating func clearURL() {self._url = nil}

    public var voiceActorID: Int32 {
      get {return _voiceActorID ?? 0}
      set {_voiceActorID = newValue}
    }
    /// Returns true if `voiceActorID` has been explicitly set.
    public var hasVoiceActorID: Bool {return self._voiceActorID != nil}
    /// Clears the value of `voiceActorID`. Subsequent reads from it will return its default value.
    public mutating func clearVoiceActorID() {self._voiceActorID = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _url: String? = nil
    fileprivate var _voiceActorID: Int32? = nil
  }

  public init() {}

  fileprivate var _meaningExplanation: String? = nil
  fileprivate var _readingExplanation: String? = nil
}

#if swift(>=4.2)

extension TKMVocabulary.PartOfSpeech: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TKMVocabulary.PartOfSpeech] = [
    .unknown,
    .noun,
    .numeral,
    .intransitiveVerb,
    .ichidanVerb,
    .transitiveVerb,
    .noAdjective,
    .godanVerb,
    .naAdjective,
    .iAdjective,
    .suffix,
    .adverb,
    .suruVerb,
    .prefix,
    .properNoun,
    .expression,
    .adjective,
    .interjection,
    .counter,
    .pronoun,
    .conjunction,
  ]
}

#endif  // swift(>=4.2)

public struct TKMSubject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _storage._id ?? 0}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var level: Int32 {
    get {return _storage._level ?? 0}
    set {_uniqueStorage()._level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  public var hasLevel: Bool {return _storage._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  public mutating func clearLevel() {_uniqueStorage()._level = nil}

  public var slug: String {
    get {return _storage._slug ?? String()}
    set {_uniqueStorage()._slug = newValue}
  }
  /// Returns true if `slug` has been explicitly set.
  public var hasSlug: Bool {return _storage._slug != nil}
  /// Clears the value of `slug`. Subsequent reads from it will return its default value.
  public mutating func clearSlug() {_uniqueStorage()._slug = nil}

  public var documentURL: String {
    get {return _storage._documentURL ?? String()}
    set {_uniqueStorage()._documentURL = newValue}
  }
  /// Returns true if `documentURL` has been explicitly set.
  public var hasDocumentURL: Bool {return _storage._documentURL != nil}
  /// Clears the value of `documentURL`. Subsequent reads from it will return its default value.
  public mutating func clearDocumentURL() {_uniqueStorage()._documentURL = nil}

  public var japanese: String {
    get {return _storage._japanese ?? String()}
    set {_uniqueStorage()._japanese = newValue}
  }
  /// Returns true if `japanese` has been explicitly set.
  public var hasJapanese: Bool {return _storage._japanese != nil}
  /// Clears the value of `japanese`. Subsequent reads from it will return its default value.
  public mutating func clearJapanese() {_uniqueStorage()._japanese = nil}

  /// Does not apply to radicals.
  public var readings: [TKMReading] {
    get {return _storage._readings}
    set {_uniqueStorage()._readings = newValue}
  }

  public var meanings: [TKMMeaning] {
    get {return _storage._meanings}
    set {_uniqueStorage()._meanings = newValue}
  }

  /// Does not apply to radicals.
  public var componentSubjectIds: [Int64] {
    get {return _storage._componentSubjectIds}
    set {_uniqueStorage()._componentSubjectIds = newValue}
  }

  /// Does not apply to vocabulary.
  public var amalgamationSubjectIds: [Int64] {
    get {return _storage._amalgamationSubjectIds}
    set {_uniqueStorage()._amalgamationSubjectIds = newValue}
  }

  public var radical: TKMRadical {
    get {return _storage._radical ?? TKMRadical()}
    set {_uniqueStorage()._radical = newValue}
  }
  /// Returns true if `radical` has been explicitly set.
  public var hasRadical: Bool {return _storage._radical != nil}
  /// Clears the value of `radical`. Subsequent reads from it will return its default value.
  public mutating func clearRadical() {_uniqueStorage()._radical = nil}

  public var kanji: TKMKanji {
    get {return _storage._kanji ?? TKMKanji()}
    set {_uniqueStorage()._kanji = newValue}
  }
  /// Returns true if `kanji` has been explicitly set.
  public var hasKanji: Bool {return _storage._kanji != nil}
  /// Clears the value of `kanji`. Subsequent reads from it will return its default value.
  public mutating func clearKanji() {_uniqueStorage()._kanji = nil}

  public var vocabulary: TKMVocabulary {
    get {return _storage._vocabulary ?? TKMVocabulary()}
    set {_uniqueStorage()._vocabulary = newValue}
  }
  /// Returns true if `vocabulary` has been explicitly set.
  public var hasVocabulary: Bool {return _storage._vocabulary != nil}
  /// Clears the value of `vocabulary`. Subsequent reads from it will return its default value.
  public mutating func clearVocabulary() {_uniqueStorage()._vocabulary = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case radical // = 1
    case kanji // = 2
    case vocabulary // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .radical
      case 2: self = .kanji
      case 3: self = .vocabulary
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .radical: return 1
      case .kanji: return 2
      case .vocabulary: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension TKMSubject.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TKMSubject.TypeEnum] = [
    .unknown,
    .radical,
    .kanji,
    .vocabulary,
  ]
}

#endif  // swift(>=4.2)

public struct TKMAssignment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var level: Int32 {
    get {return _level ?? 0}
    set {_level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  public var hasLevel: Bool {return self._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  public mutating func clearLevel() {self._level = nil}

  public var subjectID: Int64 {
    get {return _subjectID ?? 0}
    set {_subjectID = newValue}
  }
  /// Returns true if `subjectID` has been explicitly set.
  public var hasSubjectID: Bool {return self._subjectID != nil}
  /// Clears the value of `subjectID`. Subsequent reads from it will return its default value.
  public mutating func clearSubjectID() {self._subjectID = nil}

  public var subjectType: TKMSubject.TypeEnum {
    get {return _subjectType ?? .unknown}
    set {_subjectType = newValue}
  }
  /// Returns true if `subjectType` has been explicitly set.
  public var hasSubjectType: Bool {return self._subjectType != nil}
  /// Clears the value of `subjectType`. Subsequent reads from it will return its default value.
  public mutating func clearSubjectType() {self._subjectType = nil}

  public var availableAt: Int32 {
    get {return _availableAt ?? 0}
    set {_availableAt = newValue}
  }
  /// Returns true if `availableAt` has been explicitly set.
  public var hasAvailableAt: Bool {return self._availableAt != nil}
  /// Clears the value of `availableAt`. Subsequent reads from it will return its default value.
  public mutating func clearAvailableAt() {self._availableAt = nil}

  public var startedAt: Int32 {
    get {return _startedAt ?? 0}
    set {_startedAt = newValue}
  }
  /// Returns true if `startedAt` has been explicitly set.
  public var hasStartedAt: Bool {return self._startedAt != nil}
  /// Clears the value of `startedAt`. Subsequent reads from it will return its default value.
  public mutating func clearStartedAt() {self._startedAt = nil}

  public var srsStageNumber: Int32 {
    get {return _srsStageNumber ?? 0}
    set {_srsStageNumber = newValue}
  }
  /// Returns true if `srsStageNumber` has been explicitly set.
  public var hasSrsStageNumber: Bool {return self._srsStageNumber != nil}
  /// Clears the value of `srsStageNumber`. Subsequent reads from it will return its default value.
  public mutating func clearSrsStageNumber() {self._srsStageNumber = nil}

  public var passedAt: Int32 {
    get {return _passedAt ?? 0}
    set {_passedAt = newValue}
  }
  /// Returns true if `passedAt` has been explicitly set.
  public var hasPassedAt: Bool {return self._passedAt != nil}
  /// Clears the value of `passedAt`. Subsequent reads from it will return its default value.
  public mutating func clearPassedAt() {self._passedAt = nil}

  public var burnedAt: Int32 {
    get {return _burnedAt ?? 0}
    set {_burnedAt = newValue}
  }
  /// Returns true if `burnedAt` has been explicitly set.
  public var hasBurnedAt: Bool {return self._burnedAt != nil}
  /// Clears the value of `burnedAt`. Subsequent reads from it will return its default value.
  public mutating func clearBurnedAt() {self._burnedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Int64? = nil
  fileprivate var _level: Int32? = nil
  fileprivate var _subjectID: Int64? = nil
  fileprivate var _subjectType: TKMSubject.TypeEnum? = nil
  fileprivate var _availableAt: Int32? = nil
  fileprivate var _startedAt: Int32? = nil
  fileprivate var _srsStageNumber: Int32? = nil
  fileprivate var _passedAt: Int32? = nil
  fileprivate var _burnedAt: Int32? = nil
}

public struct TKMProgress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var meaningWrong: Bool {
    get {return _meaningWrong ?? false}
    set {_meaningWrong = newValue}
  }
  /// Returns true if `meaningWrong` has been explicitly set.
  public var hasMeaningWrong: Bool {return self._meaningWrong != nil}
  /// Clears the value of `meaningWrong`. Subsequent reads from it will return its default value.
  public mutating func clearMeaningWrong() {self._meaningWrong = nil}

  public var readingWrong: Bool {
    get {return _readingWrong ?? false}
    set {_readingWrong = newValue}
  }
  /// Returns true if `readingWrong` has been explicitly set.
  public var hasReadingWrong: Bool {return self._readingWrong != nil}
  /// Clears the value of `readingWrong`. Subsequent reads from it will return its default value.
  public mutating func clearReadingWrong() {self._readingWrong = nil}

  public var isLesson: Bool {
    get {return _isLesson ?? false}
    set {_isLesson = newValue}
  }
  /// Returns true if `isLesson` has been explicitly set.
  public var hasIsLesson: Bool {return self._isLesson != nil}
  /// Clears the value of `isLesson`. Subsequent reads from it will return its default value.
  public mutating func clearIsLesson() {self._isLesson = nil}

  public var assignment: TKMAssignment {
    get {return _assignment ?? TKMAssignment()}
    set {_assignment = newValue}
  }
  /// Returns true if `assignment` has been explicitly set.
  public var hasAssignment: Bool {return self._assignment != nil}
  /// Clears the value of `assignment`. Subsequent reads from it will return its default value.
  public mutating func clearAssignment() {self._assignment = nil}

  public var createdAt: Int32 {
    get {return _createdAt ?? 0}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var meaningWrongCount: Int32 {
    get {return _meaningWrongCount ?? 0}
    set {_meaningWrongCount = newValue}
  }
  /// Returns true if `meaningWrongCount` has been explicitly set.
  public var hasMeaningWrongCount: Bool {return self._meaningWrongCount != nil}
  /// Clears the value of `meaningWrongCount`. Subsequent reads from it will return its default value.
  public mutating func clearMeaningWrongCount() {self._meaningWrongCount = nil}

  public var readingWrongCount: Int32 {
    get {return _readingWrongCount ?? 0}
    set {_readingWrongCount = newValue}
  }
  /// Returns true if `readingWrongCount` has been explicitly set.
  public var hasReadingWrongCount: Bool {return self._readingWrongCount != nil}
  /// Clears the value of `readingWrongCount`. Subsequent reads from it will return its default value.
  public mutating func clearReadingWrongCount() {self._readingWrongCount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _meaningWrong: Bool? = nil
  fileprivate var _readingWrong: Bool? = nil
  fileprivate var _isLesson: Bool? = nil
  fileprivate var _assignment: TKMAssignment? = nil
  fileprivate var _createdAt: Int32? = nil
  fileprivate var _meaningWrongCount: Int32? = nil
  fileprivate var _readingWrongCount: Int32? = nil
}

public struct TKMStudyMaterials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var subjectID: Int64 {
    get {return _subjectID ?? 0}
    set {_subjectID = newValue}
  }
  /// Returns true if `subjectID` has been explicitly set.
  public var hasSubjectID: Bool {return self._subjectID != nil}
  /// Clears the value of `subjectID`. Subsequent reads from it will return its default value.
  public mutating func clearSubjectID() {self._subjectID = nil}

  public var meaningNote: String {
    get {return _meaningNote ?? String()}
    set {_meaningNote = newValue}
  }
  /// Returns true if `meaningNote` has been explicitly set.
  public var hasMeaningNote: Bool {return self._meaningNote != nil}
  /// Clears the value of `meaningNote`. Subsequent reads from it will return its default value.
  public mutating func clearMeaningNote() {self._meaningNote = nil}

  public var readingNote: String {
    get {return _readingNote ?? String()}
    set {_readingNote = newValue}
  }
  /// Returns true if `readingNote` has been explicitly set.
  public var hasReadingNote: Bool {return self._readingNote != nil}
  /// Clears the value of `readingNote`. Subsequent reads from it will return its default value.
  public mutating func clearReadingNote() {self._readingNote = nil}

  public var meaningSynonyms: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Int64? = nil
  fileprivate var _subjectID: Int64? = nil
  fileprivate var _meaningNote: String? = nil
  fileprivate var _readingNote: String? = nil
}

public struct TKMUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  public var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  public mutating func clearUsername() {self._username = nil}

  public var level: Int32 {
    get {return _level ?? 0}
    set {_level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  public var hasLevel: Bool {return self._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  public mutating func clearLevel() {self._level = nil}

  public var maxLevelGrantedBySubscription: Int32 {
    get {return _maxLevelGrantedBySubscription ?? 0}
    set {_maxLevelGrantedBySubscription = newValue}
  }
  /// Returns true if `maxLevelGrantedBySubscription` has been explicitly set.
  public var hasMaxLevelGrantedBySubscription: Bool {return self._maxLevelGrantedBySubscription != nil}
  /// Clears the value of `maxLevelGrantedBySubscription`. Subsequent reads from it will return its default value.
  public mutating func clearMaxLevelGrantedBySubscription() {self._maxLevelGrantedBySubscription = nil}

  public var profileURL: String {
    get {return _profileURL ?? String()}
    set {_profileURL = newValue}
  }
  /// Returns true if `profileURL` has been explicitly set.
  public var hasProfileURL: Bool {return self._profileURL != nil}
  /// Clears the value of `profileURL`. Subsequent reads from it will return its default value.
  public mutating func clearProfileURL() {self._profileURL = nil}

  public var startedAt: Int32 {
    get {return _startedAt ?? 0}
    set {_startedAt = newValue}
  }
  /// Returns true if `startedAt` has been explicitly set.
  public var hasStartedAt: Bool {return self._startedAt != nil}
  /// Clears the value of `startedAt`. Subsequent reads from it will return its default value.
  public mutating func clearStartedAt() {self._startedAt = nil}

  public var subscribed: Bool {
    get {return _subscribed ?? false}
    set {_subscribed = newValue}
  }
  /// Returns true if `subscribed` has been explicitly set.
  public var hasSubscribed: Bool {return self._subscribed != nil}
  /// Clears the value of `subscribed`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribed() {self._subscribed = nil}

  public var subscriptionEndsAt: Int32 {
    get {return _subscriptionEndsAt ?? 0}
    set {_subscriptionEndsAt = newValue}
  }
  /// Returns true if `subscriptionEndsAt` has been explicitly set.
  public var hasSubscriptionEndsAt: Bool {return self._subscriptionEndsAt != nil}
  /// Clears the value of `subscriptionEndsAt`. Subsequent reads from it will return its default value.
  public mutating func clearSubscriptionEndsAt() {self._subscriptionEndsAt = nil}

  public var vacationStartedAt: Int32 {
    get {return _vacationStartedAt ?? 0}
    set {_vacationStartedAt = newValue}
  }
  /// Returns true if `vacationStartedAt` has been explicitly set.
  public var hasVacationStartedAt: Bool {return self._vacationStartedAt != nil}
  /// Clears the value of `vacationStartedAt`. Subsequent reads from it will return its default value.
  public mutating func clearVacationStartedAt() {self._vacationStartedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _username: String? = nil
  fileprivate var _level: Int32? = nil
  fileprivate var _maxLevelGrantedBySubscription: Int32? = nil
  fileprivate var _profileURL: String? = nil
  fileprivate var _startedAt: Int32? = nil
  fileprivate var _subscribed: Bool? = nil
  fileprivate var _subscriptionEndsAt: Int32? = nil
  fileprivate var _vacationStartedAt: Int32? = nil
}

public struct TKMFormattedText {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var format: [TKMFormattedText.Format] = []

  public var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  public var linkURL: String {
    get {return _linkURL ?? String()}
    set {_linkURL = newValue}
  }
  /// Returns true if `linkURL` has been explicitly set.
  public var hasLinkURL: Bool {return self._linkURL != nil}
  /// Clears the value of `linkURL`. Subsequent reads from it will return its default value.
  public mutating func clearLinkURL() {self._linkURL = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Format: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case radical // = 1
    case kanji // = 2
    case japanese // = 3
    case reading // = 4
    case vocabulary // = 5
    case italic // = 6
    case bold // = 7
    case link // = 8
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .radical
      case 2: self = .kanji
      case 3: self = .japanese
      case 4: self = .reading
      case 5: self = .vocabulary
      case 6: self = .italic
      case 7: self = .bold
      case 8: self = .link
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .radical: return 1
      case .kanji: return 2
      case .japanese: return 3
      case .reading: return 4
      case .vocabulary: return 5
      case .italic: return 6
      case .bold: return 7
      case .link: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _text: String? = nil
  fileprivate var _linkURL: String? = nil
}

#if swift(>=4.2)

extension TKMFormattedText.Format: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TKMFormattedText.Format] = [
    .unknown,
    .radical,
    .kanji,
    .japanese,
    .reading,
    .vocabulary,
    .italic,
    .bold,
    .link,
  ]
}

#endif  // swift(>=4.2)

public struct TKMDataFileHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subjectsByLevel: [TKMSubjectsByLevel] = []

  /// The level of each subject.
  public var levelBySubject: [Int32] = []

  /// Subject IDs that no longer have any data.  The client should ignore any
  /// assignments with these subjects.
  public var deletedSubjectIds: [Int32] = []

  /// Offset of each encoded Subject message, starting from the end of this
  /// header in the file.
  public var subjectByteOffset: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TKMSubjectsByLevel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var radicals: [Int64] = []

  public var kanji: [Int64] = []

  public var vocabulary: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TKMLevel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var level: Int32 {
    get {return _level ?? 0}
    set {_level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  public var hasLevel: Bool {return self._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  public mutating func clearLevel() {self._level = nil}

  public var abandonedAt: Int32 {
    get {return _abandonedAt ?? 0}
    set {_abandonedAt = newValue}
  }
  /// Returns true if `abandonedAt` has been explicitly set.
  public var hasAbandonedAt: Bool {return self._abandonedAt != nil}
  /// Clears the value of `abandonedAt`. Subsequent reads from it will return its default value.
  public mutating func clearAbandonedAt() {self._abandonedAt = nil}

  public var completedAt: Int32 {
    get {return _completedAt ?? 0}
    set {_completedAt = newValue}
  }
  /// Returns true if `completedAt` has been explicitly set.
  public var hasCompletedAt: Bool {return self._completedAt != nil}
  /// Clears the value of `completedAt`. Subsequent reads from it will return its default value.
  public mutating func clearCompletedAt() {self._completedAt = nil}

  public var createdAt: Int32 {
    get {return _createdAt ?? 0}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var passedAt: Int32 {
    get {return _passedAt ?? 0}
    set {_passedAt = newValue}
  }
  /// Returns true if `passedAt` has been explicitly set.
  public var hasPassedAt: Bool {return self._passedAt != nil}
  /// Clears the value of `passedAt`. Subsequent reads from it will return its default value.
  public mutating func clearPassedAt() {self._passedAt = nil}

  public var startedAt: Int32 {
    get {return _startedAt ?? 0}
    set {_startedAt = newValue}
  }
  /// Returns true if `startedAt` has been explicitly set.
  public var hasStartedAt: Bool {return self._startedAt != nil}
  /// Clears the value of `startedAt`. Subsequent reads from it will return its default value.
  public mutating func clearStartedAt() {self._startedAt = nil}

  public var unlockedAt: Int32 {
    get {return _unlockedAt ?? 0}
    set {_unlockedAt = newValue}
  }
  /// Returns true if `unlockedAt` has been explicitly set.
  public var hasUnlockedAt: Bool {return self._unlockedAt != nil}
  /// Clears the value of `unlockedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUnlockedAt() {self._unlockedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Int64? = nil
  fileprivate var _level: Int32? = nil
  fileprivate var _abandonedAt: Int32? = nil
  fileprivate var _completedAt: Int32? = nil
  fileprivate var _createdAt: Int32? = nil
  fileprivate var _passedAt: Int32? = nil
  fileprivate var _startedAt: Int32? = nil
  fileprivate var _unlockedAt: Int32? = nil
}

public struct TKMDeprecatedMnemonicFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subjects: [TKMDeprecatedMnemonicFile.Subject] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Subject {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Int32 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var formattedDeprecatedMnemonic: [TKMFormattedText] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: Int32? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension TKMMeaning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Meaning"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "meaning"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._meaning) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._meaning {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMMeaning, rhs: TKMMeaning) -> Bool {
    if lhs._meaning != rhs._meaning {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMMeaning.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PRIMARY"),
    2: .same(proto: "SECONDARY"),
    3: .same(proto: "AUXILIARY_WHITELIST"),
    4: .same(proto: "BLACKLIST"),
  ]
}

extension TKMReading: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Reading"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reading"),
    2: .standard(proto: "is_primary"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._reading) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isPrimary) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._reading {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._isPrimary {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMReading, rhs: TKMReading) -> Bool {
    if lhs._reading != rhs._reading {return false}
    if lhs._isPrimary != rhs._isPrimary {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMReading.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ONYOMI"),
    2: .same(proto: "KUNYOMI"),
    3: .same(proto: "NANORI"),
  ]
}

extension TKMRadical: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Radical"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "character_image"),
    2: .same(proto: "mnemonic"),
    5: .standard(proto: "deprecated_mnemonic"),
    3: .standard(proto: "has_character_image_file"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._characterImage) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._mnemonic) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._hasCharacterImageFile_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._deprecatedMnemonic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._characterImage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._mnemonic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._hasCharacterImageFile_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._deprecatedMnemonic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMRadical, rhs: TKMRadical) -> Bool {
    if lhs._characterImage != rhs._characterImage {return false}
    if lhs._mnemonic != rhs._mnemonic {return false}
    if lhs._deprecatedMnemonic != rhs._deprecatedMnemonic {return false}
    if lhs._hasCharacterImageFile_p != rhs._hasCharacterImageFile_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMKanji: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Kanji"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meaning_mnemonic"),
    2: .standard(proto: "meaning_hint"),
    3: .standard(proto: "reading_mnemonic"),
    4: .standard(proto: "reading_hint"),
    10: .standard(proto: "visually_similar_kanji"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._meaningMnemonic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._meaningHint) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._readingMnemonic) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._readingHint) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._visuallySimilarKanji) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._meaningMnemonic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._meaningHint {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._readingMnemonic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._readingHint {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._visuallySimilarKanji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMKanji, rhs: TKMKanji) -> Bool {
    if lhs._meaningMnemonic != rhs._meaningMnemonic {return false}
    if lhs._meaningHint != rhs._meaningHint {return false}
    if lhs._readingMnemonic != rhs._readingMnemonic {return false}
    if lhs._readingHint != rhs._readingHint {return false}
    if lhs._visuallySimilarKanji != rhs._visuallySimilarKanji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMVocabulary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vocabulary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meaning_explanation"),
    2: .standard(proto: "reading_explanation"),
    3: .same(proto: "sentences"),
    4: .standard(proto: "parts_of_speech"),
    8: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._meaningExplanation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._readingExplanation) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sentences) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.partsOfSpeech) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.audio) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._meaningExplanation {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._readingExplanation {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.sentences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sentences, fieldNumber: 3)
    }
    if !self.partsOfSpeech.isEmpty {
      try visitor.visitPackedEnumField(value: self.partsOfSpeech, fieldNumber: 4)
    }
    if !self.audio.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.audio, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMVocabulary, rhs: TKMVocabulary) -> Bool {
    if lhs._meaningExplanation != rhs._meaningExplanation {return false}
    if lhs._readingExplanation != rhs._readingExplanation {return false}
    if lhs.sentences != rhs.sentences {return false}
    if lhs.partsOfSpeech != rhs.partsOfSpeech {return false}
    if lhs.audio != rhs.audio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMVocabulary.PartOfSpeech: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NOUN"),
    2: .same(proto: "NUMERAL"),
    3: .same(proto: "INTRANSITIVE_VERB"),
    4: .same(proto: "ICHIDAN_VERB"),
    5: .same(proto: "TRANSITIVE_VERB"),
    6: .same(proto: "NO_ADJECTIVE"),
    7: .same(proto: "GODAN_VERB"),
    8: .same(proto: "NA_ADJECTIVE"),
    9: .same(proto: "I_ADJECTIVE"),
    10: .same(proto: "SUFFIX"),
    11: .same(proto: "ADVERB"),
    12: .same(proto: "SURU_VERB"),
    13: .same(proto: "PREFIX"),
    14: .same(proto: "PROPER_NOUN"),
    15: .same(proto: "EXPRESSION"),
    16: .same(proto: "ADJECTIVE"),
    17: .same(proto: "INTERJECTION"),
    18: .same(proto: "COUNTER"),
    19: .same(proto: "PRONOUN"),
    20: .same(proto: "CONJUNCTION"),
  ]
}

extension TKMVocabulary.Sentence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TKMVocabulary.protoMessageName + ".Sentence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "japanese"),
    2: .same(proto: "english"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._japanese) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._english) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._japanese {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._english {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMVocabulary.Sentence, rhs: TKMVocabulary.Sentence) -> Bool {
    if lhs._japanese != rhs._japanese {return false}
    if lhs._english != rhs._english {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMVocabulary.PronunciationAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TKMVocabulary.protoMessageName + ".PronunciationAudio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .standard(proto: "voice_actor_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._voiceActorID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._voiceActorID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMVocabulary.PronunciationAudio, rhs: TKMVocabulary.PronunciationAudio) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._voiceActorID != rhs._voiceActorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMSubject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Subject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "level"),
    3: .same(proto: "slug"),
    4: .standard(proto: "document_url"),
    5: .same(proto: "japanese"),
    6: .same(proto: "readings"),
    7: .same(proto: "meanings"),
    8: .standard(proto: "component_subject_ids"),
    12: .standard(proto: "amalgamation_subject_ids"),
    9: .same(proto: "radical"),
    10: .same(proto: "kanji"),
    11: .same(proto: "vocabulary"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64? = nil
    var _level: Int32? = nil
    var _slug: String? = nil
    var _documentURL: String? = nil
    var _japanese: String? = nil
    var _readings: [TKMReading] = []
    var _meanings: [TKMMeaning] = []
    var _componentSubjectIds: [Int64] = []
    var _amalgamationSubjectIds: [Int64] = []
    var _radical: TKMRadical? = nil
    var _kanji: TKMKanji? = nil
    var _vocabulary: TKMVocabulary? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _level = source._level
      _slug = source._slug
      _documentURL = source._documentURL
      _japanese = source._japanese
      _readings = source._readings
      _meanings = source._meanings
      _componentSubjectIds = source._componentSubjectIds
      _amalgamationSubjectIds = source._amalgamationSubjectIds
      _radical = source._radical
      _kanji = source._kanji
      _vocabulary = source._vocabulary
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._level) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._documentURL) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._japanese) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._readings) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._meanings) }()
        case 8: try { try decoder.decodeRepeatedInt64Field(value: &_storage._componentSubjectIds) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._radical) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._kanji) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._vocabulary) }()
        case 12: try { try decoder.decodeRepeatedInt64Field(value: &_storage._amalgamationSubjectIds) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._level {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._slug {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._documentURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._japanese {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if !_storage._readings.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._readings, fieldNumber: 6)
      }
      if !_storage._meanings.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._meanings, fieldNumber: 7)
      }
      if !_storage._componentSubjectIds.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._componentSubjectIds, fieldNumber: 8)
      }
      if let v = _storage._radical {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._kanji {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._vocabulary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._amalgamationSubjectIds.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._amalgamationSubjectIds, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMSubject, rhs: TKMSubject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._level != rhs_storage._level {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._documentURL != rhs_storage._documentURL {return false}
        if _storage._japanese != rhs_storage._japanese {return false}
        if _storage._readings != rhs_storage._readings {return false}
        if _storage._meanings != rhs_storage._meanings {return false}
        if _storage._componentSubjectIds != rhs_storage._componentSubjectIds {return false}
        if _storage._amalgamationSubjectIds != rhs_storage._amalgamationSubjectIds {return false}
        if _storage._radical != rhs_storage._radical {return false}
        if _storage._kanji != rhs_storage._kanji {return false}
        if _storage._vocabulary != rhs_storage._vocabulary {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMSubject.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "RADICAL"),
    2: .same(proto: "KANJI"),
    3: .same(proto: "VOCABULARY"),
  ]
}

extension TKMAssignment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Assignment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "level"),
    3: .standard(proto: "subject_id"),
    4: .standard(proto: "subject_type"),
    5: .standard(proto: "available_at"),
    6: .standard(proto: "started_at"),
    7: .standard(proto: "srs_stage_number"),
    8: .standard(proto: "passed_at"),
    9: .standard(proto: "burned_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._level) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._subjectID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._subjectType) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._availableAt) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._startedAt) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._srsStageNumber) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._passedAt) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self._burnedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._level {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._subjectID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._subjectType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }
    if let v = self._availableAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._startedAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._srsStageNumber {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._passedAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._burnedAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMAssignment, rhs: TKMAssignment) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._level != rhs._level {return false}
    if lhs._subjectID != rhs._subjectID {return false}
    if lhs._subjectType != rhs._subjectType {return false}
    if lhs._availableAt != rhs._availableAt {return false}
    if lhs._startedAt != rhs._startedAt {return false}
    if lhs._srsStageNumber != rhs._srsStageNumber {return false}
    if lhs._passedAt != rhs._passedAt {return false}
    if lhs._burnedAt != rhs._burnedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Progress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "meaning_wrong"),
    4: .standard(proto: "reading_wrong"),
    5: .standard(proto: "is_lesson"),
    6: .same(proto: "assignment"),
    7: .standard(proto: "created_at"),
    8: .standard(proto: "meaning_wrong_count"),
    9: .standard(proto: "reading_wrong_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularBoolField(value: &self._meaningWrong) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._readingWrong) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._isLesson) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._assignment) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._createdAt) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._meaningWrongCount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self._readingWrongCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._meaningWrong {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._readingWrong {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._isLesson {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._assignment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._createdAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._meaningWrongCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._readingWrongCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMProgress, rhs: TKMProgress) -> Bool {
    if lhs._meaningWrong != rhs._meaningWrong {return false}
    if lhs._readingWrong != rhs._readingWrong {return false}
    if lhs._isLesson != rhs._isLesson {return false}
    if lhs._assignment != rhs._assignment {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._meaningWrongCount != rhs._meaningWrongCount {return false}
    if lhs._readingWrongCount != rhs._readingWrongCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMStudyMaterials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StudyMaterials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "subject_id"),
    3: .standard(proto: "meaning_note"),
    4: .standard(proto: "reading_note"),
    5: .standard(proto: "meaning_synonyms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._subjectID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._meaningNote) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._readingNote) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.meaningSynonyms) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._subjectID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._meaningNote {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._readingNote {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if !self.meaningSynonyms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.meaningSynonyms, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMStudyMaterials, rhs: TKMStudyMaterials) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._subjectID != rhs._subjectID {return false}
    if lhs._meaningNote != rhs._meaningNote {return false}
    if lhs._readingNote != rhs._readingNote {return false}
    if lhs.meaningSynonyms != rhs.meaningSynonyms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "level"),
    3: .standard(proto: "max_level_granted_by_subscription"),
    4: .standard(proto: "profile_url"),
    5: .standard(proto: "started_at"),
    6: .same(proto: "subscribed"),
    7: .standard(proto: "subscription_ends_at"),
    8: .standard(proto: "vacation_started_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._username) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._level) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._maxLevelGrantedBySubscription) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._profileURL) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._startedAt) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._subscribed) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._subscriptionEndsAt) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._vacationStartedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._level {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._maxLevelGrantedBySubscription {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._profileURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._startedAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._subscribed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    if let v = self._subscriptionEndsAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._vacationStartedAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMUser, rhs: TKMUser) -> Bool {
    if lhs._username != rhs._username {return false}
    if lhs._level != rhs._level {return false}
    if lhs._maxLevelGrantedBySubscription != rhs._maxLevelGrantedBySubscription {return false}
    if lhs._profileURL != rhs._profileURL {return false}
    if lhs._startedAt != rhs._startedAt {return false}
    if lhs._subscribed != rhs._subscribed {return false}
    if lhs._subscriptionEndsAt != rhs._subscriptionEndsAt {return false}
    if lhs._vacationStartedAt != rhs._vacationStartedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMFormattedText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FormattedText"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .same(proto: "text"),
    3: .standard(proto: "link_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.format) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._linkURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.format.isEmpty {
      try visitor.visitPackedEnumField(value: self.format, fieldNumber: 1)
    }
    if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._linkURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMFormattedText, rhs: TKMFormattedText) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs._text != rhs._text {return false}
    if lhs._linkURL != rhs._linkURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMFormattedText.Format: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "RADICAL"),
    2: .same(proto: "KANJI"),
    3: .same(proto: "JAPANESE"),
    4: .same(proto: "READING"),
    5: .same(proto: "VOCABULARY"),
    6: .same(proto: "ITALIC"),
    7: .same(proto: "BOLD"),
    8: .same(proto: "LINK"),
  ]
}

extension TKMDataFileHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataFileHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subjects_by_level"),
    4: .standard(proto: "level_by_subject"),
    3: .standard(proto: "deleted_subject_ids"),
    2: .standard(proto: "subject_byte_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subjectsByLevel) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.subjectByteOffset) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.deletedSubjectIds) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.levelBySubject) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subjectsByLevel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subjectsByLevel, fieldNumber: 1)
    }
    if !self.subjectByteOffset.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.subjectByteOffset, fieldNumber: 2)
    }
    if !self.deletedSubjectIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.deletedSubjectIds, fieldNumber: 3)
    }
    if !self.levelBySubject.isEmpty {
      try visitor.visitPackedInt32Field(value: self.levelBySubject, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMDataFileHeader, rhs: TKMDataFileHeader) -> Bool {
    if lhs.subjectsByLevel != rhs.subjectsByLevel {return false}
    if lhs.levelBySubject != rhs.levelBySubject {return false}
    if lhs.deletedSubjectIds != rhs.deletedSubjectIds {return false}
    if lhs.subjectByteOffset != rhs.subjectByteOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMSubjectsByLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubjectsByLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "radicals"),
    2: .same(proto: "kanji"),
    3: .same(proto: "vocabulary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.radicals) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.kanji) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.vocabulary) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.radicals.isEmpty {
      try visitor.visitPackedInt64Field(value: self.radicals, fieldNumber: 1)
    }
    if !self.kanji.isEmpty {
      try visitor.visitPackedInt64Field(value: self.kanji, fieldNumber: 2)
    }
    if !self.vocabulary.isEmpty {
      try visitor.visitPackedInt64Field(value: self.vocabulary, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMSubjectsByLevel, rhs: TKMSubjectsByLevel) -> Bool {
    if lhs.radicals != rhs.radicals {return false}
    if lhs.kanji != rhs.kanji {return false}
    if lhs.vocabulary != rhs.vocabulary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Level"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "level"),
    3: .standard(proto: "abandoned_at"),
    4: .standard(proto: "completed_at"),
    5: .standard(proto: "created_at"),
    6: .standard(proto: "passed_at"),
    7: .standard(proto: "started_at"),
    8: .standard(proto: "unlocked_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._level) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._abandonedAt) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._completedAt) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._createdAt) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._passedAt) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._startedAt) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._unlockedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._level {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._abandonedAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._completedAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._createdAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._passedAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._startedAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._unlockedAt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMLevel, rhs: TKMLevel) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._level != rhs._level {return false}
    if lhs._abandonedAt != rhs._abandonedAt {return false}
    if lhs._completedAt != rhs._completedAt {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._passedAt != rhs._passedAt {return false}
    if lhs._startedAt != rhs._startedAt {return false}
    if lhs._unlockedAt != rhs._unlockedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMDeprecatedMnemonicFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeprecatedMnemonicFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subjects"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subjects) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subjects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subjects, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMDeprecatedMnemonicFile, rhs: TKMDeprecatedMnemonicFile) -> Bool {
    if lhs.subjects != rhs.subjects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TKMDeprecatedMnemonicFile.Subject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TKMDeprecatedMnemonicFile.protoMessageName + ".Subject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "formatted_deprecated_mnemonic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.formattedDeprecatedMnemonic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.formattedDeprecatedMnemonic.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.formattedDeprecatedMnemonic, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TKMDeprecatedMnemonicFile.Subject, rhs: TKMDeprecatedMnemonicFile.Subject) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.formattedDeprecatedMnemonic != rhs.formattedDeprecatedMnemonic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
